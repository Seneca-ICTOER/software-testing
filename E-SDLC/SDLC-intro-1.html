<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<link rel="icon" href="/img/pwa/icon-512x512.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#DA291C">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#DA291C">
<link rel="apple-touch-icon" href="/img/pwa/icon-192x192.png">
<link rel="mask-icon" href="/img/pwa/icon-512x512.png" color="#DA291C">
<meta name="msapplication-TileImage" content="/img/pwa/icon-512x512.png">
<meta name="msapplication-TileColor" content="#DA291C"><title data-react-helmet="true">Software Development Life Cycle | Software Testing</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://software-testing.sdds.ca/E-SDLC/SDLC-intro-1"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Software Development Life Cycle | Software Testing"><meta data-react-helmet="true" name="description" content="An overview of the software life cycle."><meta data-react-helmet="true" property="og:description" content="An overview of the software life cycle."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://software-testing.sdds.ca/E-SDLC/SDLC-intro-1"><link data-react-helmet="true" rel="alternate" href="https://software-testing.sdds.ca/E-SDLC/SDLC-intro-1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://software-testing.sdds.ca/E-SDLC/SDLC-intro-1" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5ebce48d.css">
<link rel="preload" href="/assets/js/runtime~main.3d6cd9d5.js" as="script">
<link rel="preload" href="/assets/js/main.f2fe67bb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Seneca College" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/logo-dark.svg" alt="Seneca College" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">Software Testing</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Table of Contents</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Test Data Selection</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Unit Testing</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Debugging</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Software Development Life Cycle</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/E-SDLC/SDLC-intro-1">Software Development Life Cycle</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/E-SDLC/Testing-in-SDLC-2">Testing in the Life Cycle</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/E-SDLC/STLC-3">Software Testing Life Cycle</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Quality Assurance</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Software Development Life Cycle</h1></header><p>When humans first started writing software, they really had little idea how to do it. The concept was relatively simple. Start writing software, continue writing software until complete. While this worked in the very early days for very simple software projects it started to breakdown quickly as people moved to larger more complex software projects. All of the problems came to a head in the 1960s during the system 360 operating system development project. This was an attempt to write an operating system for the IBM 360 mainframe computer. This was one of a largest, most complex software projects ever attempted. Problems started to appear during the development of the project and by the end of the project it had the same problems of so many projects of that era: over budget, behind schedule, and bug ridden. The problems were so severe that the project leader, Frederick Brooks, went on to write a book called <em>The Mythical Man Month</em> in which he documented many of the problems that the project had. The result of all this was what we refer to as the <em>software crisis</em>, where people simply declared that they did not know how to write large software.</p><p>What followed was the development of the field known as <em>software engineering</em> whose goal was to apply to software development the same kind of processes that engineers had developed for engineering projects. The work preceded in several directions. One direction involved the development of much better computer languages that detected a lot of problems at the compilation stage before they became problems during runtime. The other approach looked at the software development process itself. At that time the process was largely <em>ad hoc</em> and their goal was to try and impose a formal process on development.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="the-software-development-life-cycle">The Software Development Life Cycle<a aria-hidden="true" class="hash-link" href="#the-software-development-life-cycle" title="Direct link to heading">â€‹</a></h2><p>What came out of all this work in studying how software was written and how it should be written was the software development lifecycle, depicted in the next diagram.</p><p><img alt="&amp;quot;SDLC.&amp;quot; " src="/assets/images/systems-development-life-cycle-5b15cd2eb264026a826b24c36e0580a5.png"></p><p>You start reading this diagram at the number one and then follow the numbers around the circle. Each of these numbers has a name associated with it that describes one particular phase of the software lifecycle. The idea is that you start with the planning phase and by the time you hit the maintenance phase the product has been delivered to the customer and is being maintained. The maintenance phase is the final phase of the life cycle. Each of the phases is described below.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="planning">Planning<a aria-hidden="true" class="hash-link" href="#planning" title="Direct link to heading">â€‹</a></h3><p>This is the phase where you plan the entire project. Whatever first things you should do is make a business case for the project. You are going to have to be able to justify the cost and time for the project and that justification creates the business case for carrying through with the project. You also have to look at the software environment necessary to build the project as well as the hardware necessary to build the project. In addition to hardware and software there is the human resources that also need to be acquired that have the appropriate skills to be able to carry out the project.</p><p>Finally, one of the big things you have to do in the planning stage is determine exactly what it is that you want to build. This is what we call the requirements gathering stage. While it might seem obvious what you want to build should be, experience has shown that it is far from obvious and that many people start developing software projects without actually having a clear definition of what the software should do in the end. One of the most common reasons for project failure in the early days was not that the software could not be built nor that it was producing the wrong answers but rather that they had built the wrong software because they did not really understand the requirements of the project. Today, we take requirements very seriously and requirements gathering has become a key part of the software development process.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="analysis">Analysis<a aria-hidden="true" class="hash-link" href="#analysis" title="Direct link to heading">â€‹</a></h3><p>The analysis phase is where the software designers and architects sit down with the requirements and try and figure out how they are going to map software onto that set of requirements. The first stage is to make sure that they really do understand the requirements. The requirements might have left details out or they might be misleading in some way. During this phase, the designers need to go back to the original client and get any outstanding questions answered to make sure that they really understand the requirements. The rest of your time is spent making sure that you understand all of the implications of the requirements and how different requirements interact with one another. Once you completely understand the requirements and have answered all the questions that arose, you are ready to go on and start the next phase of designing a solution to the problem.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="design">Design<a aria-hidden="true" class="hash-link" href="#design" title="Direct link to heading">â€‹</a></h3><p>The design phase is where the designers look at the requirements and try and map it onto a software solution. There is no single software solution to a problem but rather many different solutions each with their own benefits and costs. Different architectures and different technologies have to be considered in order to come up with a software solution. Once the technologies and implementation languages are chosen the design process itself can begin. This usually involves the development of high level architectures which are then refined to lower level designs. After the design is complete, then the implementation phase can begin.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="implementation">Implementation<a aria-hidden="true" class="hash-link" href="#implementation" title="Direct link to heading">â€‹</a></h3><p>The implementation phase is when the software is actually written. The design is given to the developers who then proceed to turn it into actual code. Once the code is produced, it can be compiled and then sent for testing.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="testing-and-integration">Testing and Integration<a aria-hidden="true" class="hash-link" href="#testing-and-integration" title="Direct link to heading">â€‹</a></h3><p>The testing phase is where the software is actually tested to determine if it works correctly and meets the specifications. Presumably, errors detected during testing can be corrected at this phase. Once the tests have been completed, the software can be integrated into its final environment. This could entail installing it onto customer&#x27;s hardware and software platforms and ensuring that everything works as it should. This phase will typically culminate with the customer accepting the software as meeting its requirements.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="maintenance">Maintenance<a aria-hidden="true" class="hash-link" href="#maintenance" title="Direct link to heading">â€‹</a></h3><p>The life of a software artifact does not end after it has been delivered to the customer, but rather continues, as software always requires maintenance. The maintenance phase is typically the longest phase of the life cycle and can adapt this software to:</p><ul><li>changes in requirements,</li><li>changes in legal rules,</li><li>changes to hardware,</li><li>changes to operating systems,</li><li>and any other changes which have not been anticipated.</li></ul><p>The maintenance phase is necessary to keep this software working over a longer period of time. Without maintenance, software often fails to work correctly due to its changes in its environment or fails to meet the evolving needs of the customer.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="life-cycle-models">Life Cycle Models<a aria-hidden="true" class="hash-link" href="#life-cycle-models" title="Direct link to heading">â€‹</a></h2><p>The first model of the software lifecycle was known as the waterfall model. Well this was widely adopted, problems began to appear and this was replaced by more modern models. While all of these models follow the basic steps outlined in the software development lifecycle, they each have their own unique take on how it should be done. We will examine a couple of the key lifecycle models in the following sections.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="the-waterfall-model">The Waterfall Model<a aria-hidden="true" class="hash-link" href="#the-waterfall-model" title="Direct link to heading">â€‹</a></h3><p><img alt="&amp;quot;Waterfall Life Cycle Model.&amp;quot; " src="/assets/images/waterfall-model-7fb340a7d92f56bcb82ce3534e0d45ff.jpg"></p><p>The waterfall model was the first lifecycle model to be built. It is a literal interpretation of the software lifecycle diagram shown above. One starts with planning phase and one ends with the maintenance phase. One cannot proceed on to the next phase before the previous phase is complete. As you notice from a diagram the arrows only go in the forward direction. There is no reversing to go back and fix problems that you might have found. This inability to go back and fix problems turns out to be the Achilles heel all of the waterfall model. Once a phase is complete and you go on to the next phase you often find problems which were not apparent when the previous phase was conducted. At this point you would like to go back and fix the previous phase and then continue on from there. However, the waterfall model is very rigid and says you cannot go back and fix problems even though you recognized that they do exist. As a result, projects continue knowing that they&#x27;ve got problems that might eventually cause the failure of the project.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="iterative-models">Iterative Models<a aria-hidden="true" class="hash-link" href="#iterative-models" title="Direct link to heading">â€‹</a></h3><p><img alt="&amp;quot;Iterative Life Cycle Model.&amp;quot; " src="/assets/images/iterative-model-3f84aafdb621d37fe8bc7a4f9513d6ba.jpg"></p><p>The next step was the development of iterative life cycles which stated that you might not be able to get everything right on the first try. In an intricate lifecycle you go through the entire life cycle from planning to the end of testing but you do it on only part of the project. There are many ways to break the project down into subprojects. you might split a software into totally separate pieces or you might say that in the first iteration you are going to build the high level architecture and in subsequent iterations you are going to complete different pieces of the lower level architecture.</p><p>The iterative model means that you continue to go around the life cycle until you get it right. If you are developing a particular feature, you might find that testing reveals problems at which point you can go back analyze the problem design a new solution implement it and then test that. This process will continue until you have produced a product which meets all the testing requirements.</p><p>Once again the effective models by themselves were found to be overly restrictive. They required that you go through an entire life cycle before you fix your problems. If you recognize problems in the design once you start implementation you cannot go back to the design phase and fix them but have to go around the entire life cycle again before you can fix it. Once again they found that the life cycle was overly rigid to meet the needs of modern software development.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="agile-models">Agile Models<a aria-hidden="true" class="hash-link" href="#agile-models" title="Direct link to heading">â€‹</a></h3><p>With the development of the Internet, software moved from developing products for a customer&#x27;s computers to developing software to run on the Internet. Suddenly, they had to compete directly with other people writing Internet software and they had to respond very quickly to innovations done by their competitors. They quickly found that even the iterative models could not respond fast enough. They would get partway through their design and have the requirements change due to new features which had to be worked into the design. As a result, they had to come up with a much more agile methodology that could deal with rapidly changing requirements. Previous methodologies had considered a change in requirements to be a major stumbling block that might well be the death of the project. Agile methodologies welcomed requirement changes and were able to deal with them easily.</p><p>Agile methods also ended the idea that you must complete one phase before continuing on to the next phase. They decided that once some of the requirements were known, you could go on to design part of the solution to meet those requirements. Further, once the design of part of the software was ready, you could go on to implement and even test that software. The result was that the entire team was kept continually busy. Previously, the implementation people were waiting for the designers to complete their job before they could start coding. Now, the coders can start working as soon as some of the design is completed. Letting the entire team work in parallel like this, allows for much higher productivity and reduced delivery times.</p><p>The typical agile process says that you start to gather requirements and as soon as you are sure that some of the requirements are complete you can get go onto design a solution meeting those requirements and then start to code and test that solution. Any changes in the requirements, can be accommodated easily because they typically only change one part of the software. Even if that software has already been implemented, it is still relatively small compared to the size of the entire project and is not that costly to re-implement if necessary. As a result, agile processes are no longer fearful of requirements changes but actually embrace requirements changes.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Seneca-ICTOER/software-testing/tree/main/docs/E-SDLC/SDLC-intro-1.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/D-Debugging/debug-web-6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Debugging On Web Browsers</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/E-SDLC/Testing-in-SDLC-2"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Testing in the Life Cycle<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#the-software-development-life-cycle" class="table-of-contents__link toc-highlight">The Software Development Life Cycle</a><ul><li><a href="#planning" class="table-of-contents__link toc-highlight">Planning</a></li><li><a href="#analysis" class="table-of-contents__link toc-highlight">Analysis</a></li><li><a href="#design" class="table-of-contents__link toc-highlight">Design</a></li><li><a href="#implementation" class="table-of-contents__link toc-highlight">Implementation</a></li><li><a href="#testing-and-integration" class="table-of-contents__link toc-highlight">Testing and Integration</a></li><li><a href="#maintenance" class="table-of-contents__link toc-highlight">Maintenance</a></li></ul></li><li><a href="#life-cycle-models" class="table-of-contents__link toc-highlight">Life Cycle Models</a><ul><li><a href="#the-waterfall-model" class="table-of-contents__link toc-highlight">The Waterfall Model</a></li><li><a href="#iterative-models" class="table-of-contents__link toc-highlight">Iterative Models</a></li><li><a href="#agile-models" class="table-of-contents__link toc-highlight">Agile Models</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Software Testing</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/">Contents</a></li><li class="footer__item"><a href="#" id="pwa-button" class="footer__link-item" hidden>Install as an App</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 Seneca College.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.3d6cd9d5.js"></script>
<script src="/assets/js/main.f2fe67bb.js"></script>
</body>
</html>
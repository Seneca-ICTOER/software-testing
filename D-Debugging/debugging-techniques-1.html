<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.9">
<link rel="icon" href="/img/pwa/icon-512x512.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#DA291C">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#DA291C">
<link rel="apple-touch-icon" href="/img/pwa/icon-192x192.png">
<link rel="mask-icon" href="/img/pwa/icon-512x512.png" color="#DA291C">
<meta name="msapplication-TileImage" content="/img/pwa/icon-512x512.png">
<meta name="msapplication-TileColor" content="#DA291C"><title data-react-helmet="true">Debugging Techniques | Software Testing</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://software-testing.sdds.ca/D-Debugging/debugging-techniques-1"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Debugging Techniques | Software Testing"><meta data-react-helmet="true" name="description" content="A general introduction to debugging."><meta data-react-helmet="true" property="og:description" content="A general introduction to debugging."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://software-testing.sdds.ca/D-Debugging/debugging-techniques-1"><link data-react-helmet="true" rel="alternate" href="https://software-testing.sdds.ca/D-Debugging/debugging-techniques-1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://software-testing.sdds.ca/D-Debugging/debugging-techniques-1" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.75ff2804.css">
<link rel="preload" href="/assets/js/runtime~main.5490e810.js" as="script">
<link rel="preload" href="/assets/js/main.f2fe67bb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Seneca College" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/logo-dark.svg" alt="Seneca College" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">Software Testing</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Table of Contents</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Test Data Selection</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Unit Testing</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Debugging</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/D-Debugging/debugging-techniques-1">Debugging Techniques</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/D-Debugging/vs-debugging-2">Visual Studio Debugging</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/D-Debugging/other-tools-3">Other Debugging Tools</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/D-Debugging/other-langs-4">Debugging Other Languages</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/D-Debugging/debug-linux-5">Debugging On Linux</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/D-Debugging/debug-web-6">Debugging On Web Browsers</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Software Development Life Cycle</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Quality Assurance</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Debugging</h1></header><p>Debugging is the process of locating and fixing bugs in programs. This is one of the programmer&#x27;s least liked activities. It can be frustrating, labor intensive, and sometimes downright painful. As programmers mature, they realized that it is often better to write the code carefully and avoid bugs that it is to go through the pain of finding and fixing the bugs.</p><p>The debugging process is similar to being a detective. You take a look at your program and you see that it is not performing as it should. The fact that it&#x27;s not performing correctly is evidence which you can then use to try and determine the location of the bug. In many cases the evidence that is immediately available is not sufficient to locate the bug and you have to gain more evidence. The techniques to gain more evidence include:</p><ul><li><p>inserting print statements to determine where the code is executing and what the values of variables are.</p></li><li><p>Creating a log file which will capture the output of numerous print statements to give you an up to date picture of what the software has been doing.</p></li><li><p>Using an interactive debugger to stop the program in mid execution and examine the state of the variables. Debuggers also allow you to resume execution, step-by-step, and watch the program as it executes to examine the values of the variables as they change during execution.</p></li></ul><p><img alt="&amp;quot;Debugging Cycle&amp;quot; " src="/assets/images/debug-process-edd06652f629ce7244c710854ef629bd.jpg"></p><p>Which of these debugging techniques you use depends greatly on the tools you have available to you as well as the type of program you are trying to debug. For a simple program that is relatively short, inserting some print statements might be the simplest way to gather the evidence. In other cases, you might have a distributed program which is running on multiple computers over a network. In this situation, it is difficult to gather all the data from the different machines and log files are the best solution. For programs running on a single machine that are more complicated, interactive debuggers are usually the best choice. Nothing says you have to use just one technique since you can combine different techniques depending on the type of problem you&#x27;re dealing with.</p><p>One of the difficulties of a print statement is that output is usually buffered. This means that when a program terminates suddenly output can be left in a buffer and never actually print on the screen or other output device. This can cause the programmer to believe that the code was in a different position than it really was when it terminated. To get around this problem, you should flush the output streams regularly to make sure that no output is left in the buffers when the program terminates abnormally.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="types-of-errors">Types of Errors<a aria-hidden="true" class="hash-link" href="#types-of-errors" title="Direct link to heading">â€‹</a></h2><p>Computers have two very different types of errors. One is the syntactic error which happens when your program does not follow the rules of the programming language. Syntactic errors are detected by the compiler at compile time and generate either a warning or an error. Warnings do not stop the execution of your program but they do indicate that the compiler has detected that you are doing something very unusual. Many students ignore warnings because they do not stop the program from executing. However, warnings should not be ignored as they often give a clue as to a problem which has yet to manifest itself. Errors actually stop the compiler from generating the code and they are far more serious violations of the programming language syntax. Errors must be corrected before you can generate working code.</p><p>Fortunately, the compiler produces good error messages which usually tell you the exact line that has the problem and give an indication of what the problem is. While these messages might appear cryptic when you first see them, as you get more experienced, you will find that they are actually quite easy to decipher.</p><p>C compilers are very good at generating a large number of compile time error messages. These messages are often much larger than the actual cause of the messages. Often, many messages can be generated from something as simple as forgetting to include a header file. Just because the compiler says your program has 200 error messages doesn&#x27;t mean that there are 200 separate errors you need to fix. It could be that there are only about a dozen. It is common for an error in a header file to be included into multiple implementation files resulting in the replication of error messages.</p><p>The other type of error is a runtime error or what we call a semantic error. These occur because your program doesn&#x27;t do the right thing. You detect them when you run the program by observing that the program fails or by observing that it produces incorrect output. These semantic errors are often far more difficult to find than the syntactic errors. We will not spend a lot of time on syntactic errors in this course and will concentrate primarily on semantic errors.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="warnings">Warnings<a aria-hidden="true" class="hash-link" href="#warnings" title="Direct link to heading">â€‹</a></h3><p>In addition to compilation errors, compilers produce warnings. These are not severe enough to stop comiplation but serve to tell the programmer that something unusual is being done by the programmer or that the compiler is making an automatic conversion or has made an assumption. Many beginning programmers ignore these messages since they do not stop comiplation. This is a mistake since they often contain important information that points to what will become a sematic error in the running program. Programmers ignore wanrings at their peril! Each warning should be examined, understood and corrected, if possible. Programmers should strive for programs that produce no warnings.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="link-errors">Link Errors<a aria-hidden="true" class="hash-link" href="#link-errors" title="Direct link to heading">â€‹</a></h3><p>Another source of errors are from the linker. To understand what these messages mean, we need to review the process of separate compilation, depicted below.</p><p><img alt="&amp;quot;Separate Compilation&amp;quot; " src="/assets/images/separate-compilation-7f0ef244f342f439c836222fa32ed959.jpg"></p><p>Once you break your program into separate <strong>.c</strong> source code files, you will be using separate compilation. This means that each source file is compiled separately to produce an object file. The object file is the compiled version of the code, represented as native instructions for your particular CPU. Since your main.c references functions in functions.c, these references need to be fixed so that main knows where to find the functions it calls. Putting the object files together and fixing the reference to functions in other object files is the job of a program called the <strong>linker</strong>.</p><p>The linker produces its own error messages which say one of two things:</p><ul><li>It was looking for something and could not find it,</li><li>It was looking for something and found two or more of it.</li></ul><p>When the linker goes looking for a variable or function, it expects to find one of what it is looking for. If it finds zero, it cannot complete the link process as part of the code is missing. If it finds two definitions of the same thing, then it is left not knowing which it should use so it abandons the linking process.</p><p>All linker errors come down to one of these two errors. The trouble is that the messages from the linker are often not clear. This is particularly a problem when working with template-based C++ code where the messages can span multiple lines. What you need to remember is that it is saying that it either did not find something or found two of something. Then, read the message carefully looking for names that you recognize that indicate what is missing or duplicated.</p><p>Many people wonder why the header files are not compiled. Header files are textually included in the C implementation files, which are then compiled. This means that your header functions are compiled, but only by being included in the implementation files.</p><p>The common reasons for getting a message from the linker are:</p><ul><li>you wrote the declaration for a function or variable and forgot to write the definition,</li><li>you forgot you already defined a function or variable and defined it twice,</li><li>you accidentally used the same name in different parts of the program,</li><li>you omitted one of the object files that should have been sent to the linker.</li></ul><p>It is important that you understand the difference between declaration and definition. When you write the function prototype in a header file or an implementation file, it looks like this:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI c"><pre tabindex="0" class="prism-code language-c codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">square</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>The declaration tells the compiler:</p><ul><li>the name of the function,</li><li>the number and type of the parameters,</li><li>the type returned by the function.</li></ul><p>This information allows the compiler to check the types when the function is called. This is why you include header files in implementation files that will be calling the functions declared in the header files -- so the types of the parameters and return type can be checked. What we have not seen so far is the definition of the function, where we actually provide the code for the function. This is placed in an implementation file, as shown below.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI c"><pre tabindex="0" class="prism-code language-c codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">square</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> n </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>This defines what the function does and this definition is what the linker is looking for. You get an error if the linker finds zero definitions of a function or if it finds two or more definitions.</p><p>Something similar can happen with variables. Let&#x27;s say you have a header file in which you define a variable.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI c"><pre tabindex="0" class="prism-code language-c codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">ifndef</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property expression" style="color:#36acaa">HEADER_H</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">define</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property macro-name" style="color:#36acaa">HEADER_H</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">endif</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>This does not declare the variable n, but defines it. This means that it allocates memory for it and associates the memory address with the name n. If you include this into two implementation files, it will allocate memory for the same variable twice. When the object files are sent to the linker, it will find two areas of memory associated with the same variable and not know which one to use, resulting in a linker error. The way to overcome this problem is to replace the definition of the variable in the header file with a declaration.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI c"><pre tabindex="0" class="prism-code language-c codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">ifndef</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property expression" style="color:#36acaa">HEADER_H</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">define</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property macro-name" style="color:#36acaa">HEADER_H</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">extern</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">endif</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>The keyword <strong>extern</strong> indicates that this is just type information for the variable and that it will be defined elsewhere. This transforms a defintion into a declaration. While you can delcare the same function or variable multiple times, you can only define them once. Therefore, the variable n must be declared in exactly one of the implementation files. While you might think, &quot;But I use it in two implementation files...&quot;, the linker will fix it up so that all implementation code points to the single defined memory location for the variable.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="debugging-techniques">Debugging Techniques<a aria-hidden="true" class="hash-link" href="#debugging-techniques" title="Direct link to heading">â€‹</a></h2><p>There are numerous techniques you can use to try and track down the bugs in a program. When you are tracking down bugs, you need to know several pieces of information:</p><ul><li><p>Where the program was executing when the bug occurred,</p></li><li><p>Whether the point of termination was where the bug occurred or whether the bug occurred long before the program terminated,</p></li><li><p>In many cases the program will not terminate but rather simply produce incorrect results. In situations like this you have to start looking at the code that calculated those results and try and figure out what went wrong with the calculations.</p></li><li><p>Often, when you see a program executing a certain piece of code, you are mystified as how it got to execute that piece of code. In situations like this you try and answer the question &quot;how did I end up executing this piece of code?&quot;.</p></li><li><p>Often you need to see the values of individual variables and watch them change to figure out exactly what is going wrong.</p><p>Debugging can be very complicated and many bugs are elusive and very difficult to track down. Finding these bugs can be both frustrating and very time consuming. The key to finding them is cleverness and persistence. Sometimes a bug can take weeks to find. Fortunately, as you become more experienced, you get better at finding bugs and getting an intuition as to what causes a particular type of problem.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="debugging-clues">Debugging Clues<a aria-hidden="true" class="hash-link" href="#debugging-clues" title="Direct link to heading">â€‹</a></h2><p>As you gain experience, you will find that there are certain giveaways as to what might be the source of the bug. Bugs which totally stump novice programmers are often solved in a couple of minutes by experienced programmers. Below I will go through some of the most common reasons for bugs and how to identify them.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="segmentation-faults">Segmentation Faults<a aria-hidden="true" class="hash-link" href="#segmentation-faults" title="Direct link to heading">â€‹</a></h3><p>Modern computers and operating systems have the concept of protected memory. This means that they are easily able to recognize memory which is allocated for use by your program versus memory which has been allocated for use by another program. If your program attempts to access memory that has been not allocated to it, a segmentation fault is generated. The segmentation fault normally results in the termination of the program. The most common reasons for a segmentation fault are:</p><ul><li><p>Having subscripts which run off the end of an array. If the array is stored near the boundary of your program and another program then incorrect subscripts can cause you to access the memory outside your own program resulting in a segmentation fault. Looking for bad subscripts on arrays is one of the first things you should do.</p></li><li><p>Another common reason for segmentation faults is a bad address. When using pointers, you can generate a pointer which points to memory outside the memory allocated to your program. This results from some an error in calculating the pointer. Since the pointer accesses memory outside of your program&#x27;s memory, it generates a segmentation fault.</p></li><li><p>The third, and less common reason for a segmentation fault, would be an uninitialised variable. Some compilers make it difficult to have uninitialized variables while other compilers allow the use of uninitialized variables. Uninitialized variables can have random values depending on where they occur. In general, we treat an initialized variable as having a random value and, if this variable is used as a pointer, it can often address memory outside of your program.</p></li><li><p>one of the most common values to cause a segmentation fault is a NULL pointer. NULL has the value zero and this references part of the operating system. If you find that the pointer that caused the segmentation fault has the value of NULL or zero then you should figure out why it was not calculated to have the correct value.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="bus-error">Bus Error<a aria-hidden="true" class="hash-link" href="#bus-error" title="Direct link to heading">â€‹</a></h3><p>The bus error is similar to the segmentation fault in that it is in illegal memory access. The difference between the two is that segmentation fault address is valid memory that is not allocated to your program whereas a bus error access is memory which does not exist. The reasons for the bus error are similar to that of a segmentation fault and you should follow them down using the same debugging techniques.</p><p>Another problem which can cause a bus error is attempting to access memory which has been deallocated. Once you start doing dynamic memory allocation, it is possible for you to keep pointers to memory that you&#x27;ve already deallocated. Attempting to use these pointers to access the memory which has been deallocated can result in a segmentation fault.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="random-behaviour">Random Behaviour<a aria-hidden="true" class="hash-link" href="#random-behaviour" title="Direct link to heading">â€‹</a></h3><p>Random behavior where your program behaves differently every time it is run is almost always a result of uninitialized variables. The reason the program is behaving randomly is because every time it accesses a variable it gets the value that was in that location previously. Since that value is probably close to random, it causes your program to behave in a different way every time it is run. Whenever you see random behavior, the first thing to look for is uninitialized variables.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="program-executes-the-wrong-code">Program Executes The Wrong Code<a aria-hidden="true" class="hash-link" href="#program-executes-the-wrong-code" title="Direct link to heading">â€‹</a></h3><p>Occasionally, you will find that your program is executing code that it should have been executing. When you look at a stack trace, you might find part of a stack trace missing. These are symptoms that there is a much larger problem in your program. It means that your program took a random jump and ended up in some code that it shouldn&#x27;t have. This could be a bad pointer or it could be some strange problem with the program. This is one of the most difficult and challenging bugs to identify.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="my-variable-just-changed-its-value">My Variable Just Changed itâ€™s Value<a aria-hidden="true" class="hash-link" href="#my-variable-just-changed-its-value" title="Direct link to heading">â€‹</a></h3><p>if you ever find that a variable seems to have changed its value on its own, then some other piece of code must have changed the value. Tracking down this other piece of code can be particularly difficult. Often it is the result of running off the end of an array or using a bad pointer which does not reach outside your memory space for your program but just accesses valid memory within your program.</p><p>Compilers generally layout memory linearly as the variables are declared. Take a look at where you declared the variable whose value is being changed. If you find it is declared right before or after an array then check to make sure that the bounds of those arrays are not being exceeded. On the other hand, if it is caused by a bad pointer, it can be very difficult to locate where the bad pointer was generated. Some debuggers have a watch feature where you can watch a particular memory location and have the debugger notify you whenever that location is changed. This is one of the few techniques that will help you debug this type of problem.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="my-program-works-on-one-compiler-and-fails-on-another">My Program Works on One Compiler and Fails on Another<a aria-hidden="true" class="hash-link" href="#my-program-works-on-one-compiler-and-fails-on-another" title="Direct link to heading">â€‹</a></h3><p>Most students think that this is a fault of the computer or the compiler. While it is possible that the computer or the compiler can make mistakes this is extremely rare. These compilers are used by thousands and thousands of people every day and if there is a bug in them it is found and corrected quickly. It is far more likely that the problem is in your program.</p><p>The reasons why programs behave differently on different compilers and operating systems is because different compilers on different operating systems do different things. For example, on Unix operating systems, memory is usually not zeroed out before being given to a new program. On Windows you could always depend on your memory to have been zeroed out before being handed to your program. The other big difference is in how compilers layout and allocate memory. Some compilers will do byte alignment where they extend variables to give them a little extra space for the word size of a particular computer. If you switch to a computer with a different word size then it will have different padding between variables to make sure that the variables start on a word boundary. This small difference in spacing can result in a program working on one compiler but failing on another compiler. The real reason for this is most likely you&#x27;ve either got in index exceeding the bounds of an array or an invalid pointer. On one of the compilers this bad memory address simply accesses some of the empty space between the variables used for padding whereas in the other compiler it accesses a real variable and corrupts its value. The fault for this lies not with the compilers but rather with your program. If your program was working perfectly it would work perfectly on both compilers.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="my-program-just-stopped">My Program Just Stopped!<a aria-hidden="true" class="hash-link" href="#my-program-just-stopped" title="Direct link to heading">â€‹</a></h3><p>If you find that your program stops in the middle of execution for no reason, you should consider the possibility that you might have handled an exception or a signal. C programs allow you to install signal handlers that will intercept signals sent to your program and do something with them. These signal handlers can catch segmentation faults and bus errors and allow the program to continue to execute. The reason the signal handlers are available is to allow the programmer to catch erroneous conditions and to try and do something intelligent to recover from them. Many students find the signals that are causing the program to stop execution to be very annoying and they install a signal handler which does nothing. This can have very strange effects. It creates a program which should have stopped yet is continuing to blunder along. What exactly will happen with this program is almost impossible to predict.</p><p>Most languages have an exception facility where code which has a problem will throw an exception. Exceptions can be caught in a try-catch statement and then handled in an effort to recover from the error. Once again, many programmers find these errors inconvenient so they install a try catch which catches the exceptions and does nothing. If your program just stops without any error messages, then you should consider the possibility that you have put some erroneous code inside a try-catch, it throws an exception, you catch the exception, and do nothing. The operating system then terminates your program and it has the appearance that it just stopped. Catching an exception and doing nothing is usually a bad idea.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="memory-errors">Memory Errors<a aria-hidden="true" class="hash-link" href="#memory-errors" title="Direct link to heading">â€‹</a></h3><p><img alt="&amp;quot;Application memory layout&amp;quot; " src="/assets/images/memory-layout-171e44f428540081e34177f727790659.jpg"></p><p>Computer memory for an application is divided into four main parts:</p><ul><li>an area for constants. When you create a constant in a program, it is stored directly in the image on disk. This means that the constants are loaded into memory along with the executable code. This saves having to assign values to them at run-time since their values are assigned as part of the loading of the program.</li><li>An area holding the executable code. This is the binary representation of the code you wrote that is ready to run.</li><li>A stack onto which stack frames are placed every time a function is called. The stack frames contain the memory for all the local variables inside the function. Each time a function is called, a new stack frame is created for it and, when the function returns, the stack frame is removed from the run-time stack. The next function call will place a new frame on the stack which will overwrite a previous stack frame, destroying any values stored there. When you inherit space on the stack which was used previously, it will have the values from the previous function in it and you need to initialize all your variables to avoid getting random values in them.</li><li>A heap from which memory can be dynamically allocated. This is what is used when you use the <em>new</em> and <em>delete</em> operators in C++ or the <em>allocate</em> and <em>free</em> functions in C. The heap is automatically managed to find memory of the size you need and to make memory that was freed available for reuse. These algorithms get very confused if you delete the same memory twice, leading to unpredictable errors.</li></ul><p>Some languages, like Java and C#, offer <em>managed memory</em>. This means that there is a <em>new</em> operator to allocate an object but no <em>delete</em> operator to make the memory available again. These languages keep a count of the number of references to each dynamically allocated variable. When that count drops to zero, no one is using the variable anymore and it is marked available for reuse. A separate thread runs a <em>garbage collector</em> which is responsible for gathering up these variables and making them available to be used again. Some of these languages allow you to give hints to the garbage collector to run and reclaim memory. This can give your program more heap memory when it starts to run out.</p><p>One thing that can go wrong with memory is to exhaust the stack space. This happens because you&#x27;ve called so many functions that you have literally used up all the memory allocated for the runtime stack. The possible reasons for this include:</p><ul><li>You&#x27;re storing a very large number of local variables or large arrays as local variables inside the functions. If this is the case, you should consider reducing the number of variables or using dynamic allocation to allocate the space from the heap rather than from the stack.</li><li>You have a case of infinite recursion. Recursion is defined as when a function calls itself. This might be either directly where the function calls itself or indirectly where a function calls another function which then calls the original function. Regardless of how it happens, if you are in a situation where you call a function recursively forever, you eventually exhaust the stack space. Finding infinite recursion is relatively easy because if you put a few print statements in the functions you will find that you print out large numbers of them. Once you find the location of recursion, find a way to break it and your problem will be solved.</li></ul><p>You could also exhaust the heap memory. Exhausting heap memory occurs because you allocated too much memory, which is actually fairly rare, or you have a <em>memory leak</em>. A memory leak is when you allocate memory but you never free it. This is actually very simple to do in the C language and it&#x27;s hard to find out where it&#x27;s occurring and to avoid it. Getting large C and C++ applications so that they do not have memory leaks is actually a difficult task. There are automated tools that can try and detect where this might be occurring but the best thing to do is to use smart pointers that automatically deallocate heap memory when it goes out of scope. While this solves the problem of heap memory which is only needed for the lifetime of a function, it doesn&#x27;t do much to solve problems of heap memory which is needed for a longer duration.</p><p>The other problem that can occur with the heap is that if you delete the same memory twice or you try and use a pointer to memory which has already been deleted, you can end up with some very strange errors. These errors can be very difficult to locate and fix.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="numeric-problems">Numeric Problems<a aria-hidden="true" class="hash-link" href="#numeric-problems" title="Direct link to heading">â€‹</a></h3><p>Several problems can occur when doing arithmetic calculations. These include:</p><ul><li><strong>Incorrect Results</strong> - You might have performed a calculation in integer arithmetic and lost the fractional part of a number.</li><li><strong>Results start OK but then change sign</strong> - Numbers are stored in a format where if a number gets too big, it wraps around and becomes negative. The problem is that you are using too small a type to store the number.</li><li><strong>Inf</strong> - this means that the result of the calculation is infinity. Look for division by zero or other arithmetic problem.</li><li><strong>NaN</strong> - Not a Number. Often due to divide by zero but might be for another reason. Regardless, the value is not a valid number.</li><li><strong>Prints a strange value</strong> - Check your format codes to make sure you are not printing an int as a float or similar type problem in a printf.</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="non-zero-return-code">Non-Zero Return Code<a aria-hidden="true" class="hash-link" href="#non-zero-return-code" title="Direct link to heading">â€‹</a></h3><p>This is difficult to debug since it could be caused by many things. Consider:</p><ul><li>divide by zero</li><li>out of memory</li></ul><p>You really need to narrow down the cause of the bug. Try running the code and stopping at various points until you hit the bug. This might give a clue as to where it is occurring. Repeatedly narrow it down until you find the line on which it occurs.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Seneca-ICTOER/software-testing/tree/main/docs/D-Debugging/debugging-techniques-1.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/C-UnitTesting/testing-coverage-3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Testing Coverage</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/D-Debugging/vs-debugging-2"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Visual Studio Debugging<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#types-of-errors" class="table-of-contents__link toc-highlight">Types of Errors</a><ul><li><a href="#warnings" class="table-of-contents__link toc-highlight">Warnings</a></li><li><a href="#link-errors" class="table-of-contents__link toc-highlight">Link Errors</a></li></ul></li><li><a href="#debugging-techniques" class="table-of-contents__link toc-highlight">Debugging Techniques</a></li><li><a href="#debugging-clues" class="table-of-contents__link toc-highlight">Debugging Clues</a><ul><li><a href="#segmentation-faults" class="table-of-contents__link toc-highlight">Segmentation Faults</a></li><li><a href="#bus-error" class="table-of-contents__link toc-highlight">Bus Error</a></li><li><a href="#random-behaviour" class="table-of-contents__link toc-highlight">Random Behaviour</a></li><li><a href="#program-executes-the-wrong-code" class="table-of-contents__link toc-highlight">Program Executes The Wrong Code</a></li><li><a href="#my-variable-just-changed-its-value" class="table-of-contents__link toc-highlight">My Variable Just Changed itâ€™s Value</a></li><li><a href="#my-program-works-on-one-compiler-and-fails-on-another" class="table-of-contents__link toc-highlight">My Program Works on One Compiler and Fails on Another</a></li><li><a href="#my-program-just-stopped" class="table-of-contents__link toc-highlight">My Program Just Stopped!</a></li><li><a href="#memory-errors" class="table-of-contents__link toc-highlight">Memory Errors</a></li><li><a href="#numeric-problems" class="table-of-contents__link toc-highlight">Numeric Problems</a></li><li><a href="#non-zero-return-code" class="table-of-contents__link toc-highlight">Non-Zero Return Code</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Software Testing</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/">Contents</a></li><li class="footer__item"><a href="#" id="pwa-button" class="footer__link-item" hidden>Install as an App</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 Seneca College.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5490e810.js"></script>
<script src="/assets/js/main.f2fe67bb.js"></script>
</body>
</html>
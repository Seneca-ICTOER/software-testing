"use strict";(self.webpackChunksft211=self.webpackChunksft211||[]).push([[481],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return g}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),h=l(n),g=o,p=h["".concat(c,".").concat(g)]||h[g]||u[g]||r;return n?i.createElement(p,s(s({ref:t},d),{},{components:n})):i.createElement(p,s({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=h;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:o,s[1]=a;for(var l=2;l<r;l++)s[l]=n[l];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4800:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return h}});var i=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],a={id:"testing-coverage-3",title:"Testing Coverage",sidebar_position:3,description:"The importance and tools for code coverage."},c="Testing Coverage",l={unversionedId:"C-UnitTesting/testing-coverage-3",id:"C-UnitTesting/testing-coverage-3",isDocsHomePage:!1,title:"Testing Coverage",description:"The importance and tools for code coverage.",source:"@site/docs/C-UnitTesting/testing-coverage-3.md",sourceDirName:"C-UnitTesting",slug:"/C-UnitTesting/testing-coverage-3",permalink:"/C-UnitTesting/testing-coverage-3",editUrl:"https://github.com/Seneca-ICTOER/software-testing/tree/main/docs/C-UnitTesting/testing-coverage-3.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"testing-coverage-3",title:"Testing Coverage",sidebar_position:3,description:"The importance and tools for code coverage."},sidebar:"courseNotesSidebar",previous:{title:"Unit Testing in Visual Studio",permalink:"/C-UnitTesting/vs-test-2"},next:{title:"Debugging Techniques",permalink:"/D-Debugging/debugging-techniques-1"}},d=[],u={toc:d};function h(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"testing-coverage"},"Testing Coverage"),(0,r.kt)("p",null,"We design our tests based upon black box and white box testing principles. This means that the test data has been selected to prove that certain inputs provide the correct outputs for black box testing as well as to drive the code through certain branches based upon white box testing. Unfortunately, we can still miss code which has never been executed by any tests. Code which has never been executed often has bugs in it that have never been found, for the obvious reason that it was never executed. The goal of testing coverage is to find the code which was executed as well as the code which has never been executed. Once we identify the code which has never been executed, we can then go on to design tests to exercise that particular piece of code."),(0,r.kt)("p",null,"Testing coverage is a facility offered by many compilers. While Visual Studio does have this capability, it is only available in the enterprise version of the tool. This means that it is not available to many programmers and therefore we will use the tool provided by GCC. While it would be preferable to do our tests in the same environment that we do our coverage analysis, it is complicated by the fact that we are using the testing tool from Visual Studio and they do not make their coverage analysis tool available to us. As a result, we will largely be demonstrating how to use coverage analysis tool without actually applying it to our testing regime."),(0,r.kt)("p",null,"In order to do testing coverage, you normally have to compile with special flags or options that tell your compiler to build in additional code that actually counts the number of times every line is executed. While theoretically, you could write your own coverage analysis tool by writing out a message every time a line was executed, this would be labor intensive to do and, even if you automated it, you would have to maintain two different versions of the code."),(0,r.kt)("p",null,"We are going to demonstrate how to do coverage using GCC with the following program which inserts one string into another."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <string.h>\n\n#define STR_SIZE 20\n\nvoid insert(char dest[], int posn, char src[])\n{\n    int dlen = strlen(dest);\n    int slen = 0, i;\n\n    if(posn < dlen)\n    {\n        slen = strlen(src);\n        for(i = dlen; i >= posn; i--)\n        {\n            dest[i + slen] = dest[i];\n        }\n\n        for(i = 0; i < slen; i++)\n        {\n            dest[posn +i] = src[i];\n        }\n    }\n    else\n    {\n        strcat(dest, src);\n    }\n}\n\nint main(void)\n{\n    char dest[STR_SIZE] = {"The fox"};\n\n    insert(dest, 4, "red ");\n    printf("%s\\n", dest);\n\n    return 0;\n}\n')),(0,r.kt)("p",null,"When we compile this code, we have to provide the additional flags to the compiler instructing it to build in the instructions to count how many times each line is executed. The command to compile the program shown above, insert.c, is:\n",(0,r.kt)("inlineCode",{parentName:"p"}," gcc -Wall -fprofile-arcs -ftest-coverage -o insert insert.c"),"\nAfter we compile the code with these flags, we then have to execute the program once to generate data that is stored in various files. These files contain the information needed to count how many times each line was executed. To prepare the files for viewing by humans, we use the gcov command:\n",(0,r.kt)("inlineCode",{parentName:"p"}," gcov insert.c"),"\nThis command produces a new file called insert.c.gcov which is shown next."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'        -:    0:Source:insert.c\n        -:    0:Graph:insert.gcno\n        -:    0:Data:insert.gcda\n        -:    0:Runs:1\n        -:    1:#include <stdio.h>\n        -:    2:#include <string.h>\n        -:    3:\n        -:    4:#define STR_SIZE 20\n        -:    5:\n        1:    6:void insert(char dest[], int posn, char src[])\n        -:    7:{\n        1:    8:    int dlen = strlen(dest);\n        1:    9:    int slen = 0, i;\n        -:   10:\n        1:   11:    if(posn < dlen)\n        -:   12:    {\n        1:   13:        slen = strlen(src);\n        5:   14:        for(i = dlen; i >= posn; i--)\n        -:   15:        {\n        4:   16:            dest[i + slen] = dest[i];\n        -:   17:        }\n        -:   18:\n        5:   19:        for(i = 0; i < slen; i++)\n        -:   20:        {\n        4:   21:            dest[posn +i] = src[i];\n        -:   22:        }\n        -:   23:    }\n        -:   24:    else\n        -:   25:    {\n    #####:   26:        strcat(dest, src);\n        -:   27:    }\n        1:   28:}\n        -:   29:\n        1:   30:int main(void)\n        -:   31:{\n        1:   32:    char dest[STR_SIZE] = {"The fox"};\n        -:   33:\n        1:   34:    insert(dest, 4, "red ");\n        1:   35:    printf("%s\\n", dest);\n        -:   36:\n        1:   37:    return 0;\n        -:   38:}\n\n')),(0,r.kt)("p",null,'This file contains the original source code and line numbers. The first column, before the line numbers, is an indication of how many times that line was executed. The symbols "-:" indicate this is not an executable line and was never executed. Hash signs (#) indicate executable lines which were never executed. These are what you should be looking for in order to find code which was not tested. The numbers in the first column are the counts of how many times each executable line was executed.'))}h.isMDXComponent=!0}}]);
"use strict";(self.webpackChunksft211=self.webpackChunksft211||[]).push([[230],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=u(n),p=o,f=d["".concat(l,".").concat(p)]||d[p]||h[p]||s;return n?i.createElement(f,a(a({ref:t},c),{},{components:n})):i.createElement(f,a({ref:t},c))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,a[1]=r;for(var u=2;u<s;u++)a[u]=n[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5337:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var i=n(7462),o=n(3366),s=(n(7294),n(3905)),a=["components"],r={id:"Testing-in-SDLC-2",title:"Testing in the Life Cycle",sidebar_position:2,description:"How testing fits into the software life cycle."},l="Testing in the Software Development Life Cycle",u={unversionedId:"E-SDLC/Testing-in-SDLC-2",id:"E-SDLC/Testing-in-SDLC-2",isDocsHomePage:!1,title:"Testing in the Life Cycle",description:"How testing fits into the software life cycle.",source:"@site/docs/E-SDLC/Testing-in-SDLC-2.md",sourceDirName:"E-SDLC",slug:"/E-SDLC/Testing-in-SDLC-2",permalink:"/E-SDLC/Testing-in-SDLC-2",editUrl:"https://github.com/Seneca-ICTOER/software-testing/tree/main/docs/E-SDLC/Testing-in-SDLC-2.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"Testing-in-SDLC-2",title:"Testing in the Life Cycle",sidebar_position:2,description:"How testing fits into the software life cycle."},sidebar:"courseNotesSidebar",previous:{title:"Software Development Life Cycle",permalink:"/E-SDLC/SDLC-intro-1"},next:{title:"Software Testing Life Cycle",permalink:"/E-SDLC/STLC-3"}},c=[{value:"Times to Test",id:"times-to-test",children:[{value:"During Requirements",id:"during-requirements",children:[],level:3},{value:"During Design",id:"during-design",children:[],level:3},{value:"During Implementation",id:"during-implementation",children:[],level:3},{value:"During Testing",id:"during-testing",children:[],level:3},{value:"During Delivery",id:"during-delivery",children:[],level:3},{value:"During Maintenance",id:"during-maintenance",children:[],level:3}],level:2},{value:"Approaches to Software Development",id:"approaches-to-software-development",children:[{value:"Incremental Development",id:"incremental-development",children:[],level:3},{value:"Continuous Integration",id:"continuous-integration",children:[],level:3},{value:"Test Driven Development",id:"test-driven-development",children:[],level:3}],level:2}],h={toc:c};function d(e){var t=e.components,r=(0,o.Z)(e,a);return(0,s.kt)("wrapper",(0,i.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"testing-in-the-software-development-life-cycle"},"Testing in the Software Development Life Cycle"),(0,s.kt)("p",null,"As we saw when we looked at the software development lifecycle, testing is one of the phases of the life cycle. What might not be obvious, is how we can fit testing into a modern agile iterative model. It turns out the testing has its own lifecycle which we can fit into the overall software development like cycle."),(0,s.kt)("h2",{id:"times-to-test"},"Times to Test"),(0,s.kt)("p",null,"Work on testing begins when the project starts and continues until the product is no longer being maintained. The following sections describe how testing can be done in the phases of the life cycle."),(0,s.kt)("h3",{id:"during-requirements"},"During Requirements"),(0,s.kt)("p",null,"During the planning phase when requirements are being gathered, we can actually start to work on our test plans. Once the requirements are partially known, we can start to:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"plan the scope of the quality assurance effort,"),(0,s.kt)("li",{parentName:"ul"},"design black box tests that will determine if the resulting software meets requirements.")),(0,s.kt)("p",null,"This will allow the quality assurance team to be active and productive even while requirements are still being gathered. Problems identified by the preparation for testing at this point can be fed back to the requirements team and corrected at low cost."),(0,s.kt)("h3",{id:"during-design"},"During Design"),(0,s.kt)("p",null,"Once the design is finalized and ready to be implemented, the testing team can start to write some of their tests now that they have a better idea of how the software is going to work. It might be possible at that point to start to design some integration tests based upon how the architecture is being revealed."),(0,s.kt)("h3",{id:"during-implementation"},"During Implementation"),(0,s.kt)("p",null,"Testing should naturally be part of the implementation process. Unit tests should be available as the software is being written so the developers can quickly check their functions to determine if they work correctly. Finding and fixing bugs in small pieces of software is relatively easy. Letting these bugs be propagated into much larger pieces of software makes them more difficult to find and fix. Therefore it is actually vital that unit testing be done by the programmers as soon as they finish the functions to make sure that they behave as they should. The quality assurance team can be writing unit tests as the developers write each function or module."),(0,s.kt)("h3",{id:"during-testing"},"During Testing"),(0,s.kt)("p",null,"You would expect that most of the testing would take place in the testing phase, however, much of the low-level unit testing was probably done during the implementation phase. What is left is:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"final integration testing to ensure the software components are completed and assembled correctly,"),(0,s.kt)("li",{parentName:"ul"},"manual testing to determine if the user interface works as required.")),(0,s.kt)("h3",{id:"during-delivery"},"During Delivery"),(0,s.kt)("p",null,"This is the phase in which acceptance testing can be conducted. The final tests can be carried out on the customer\u2019s premises with the system deployed. On passing, the customer can sign off on accepting the software."),(0,s.kt)("h3",{id:"during-maintenance"},"During Maintenance"),(0,s.kt)("p",null,"During the maintenance phase the software needs to be kept up to date and even modified to implement new requirements. This requires:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"regression testing to ensure that changes have not introduced any bugs into the existing software,"),(0,s.kt)("li",{parentName:"ul"},"test plans for new features which have been added and the execution of these tests,"),(0,s.kt)("li",{parentName:"ul"},"manual tests for changes in the user interface.")),(0,s.kt)("h2",{id:"approaches-to-software-development"},"Approaches to Software Development"),(0,s.kt)("p",null,"There are numerous approaches to software development. In this section, we will look at a couple of the most successful techniques and see how testing is used in them."),(0,s.kt)("h3",{id:"incremental-development"},"Incremental Development"),(0,s.kt)("p",null,"Incremental development is a technique that builds software in pieces. The first piece is the architectural skeleton of the system. this would be the backbone of the system that has little functionality on its own but allows the prime components to communicate with one another and it allows them to be built separately and plugged in as they are completed. This is a very successful technique because it breaks the software into much smaller pieces that need to be implemented. Further, as each component is fitted into the architectural backbone, it can be tested."),(0,s.kt)("p",null,"During incremental development the test team will be working to design new tests for the software as it is completed. These could be unit tests for the low level components as well as integration tests to determine whether the new software components have been integrated with the rest of the system correctly. As user interface components are added in, there could be manual testing to ensure that the user interface does perform as required. Incremental development also implies incremental test development and testing. This type of development allows the development team to work hand-in-hand with the quality assurance team."),(0,s.kt)("h3",{id:"continuous-integration"},"Continuous Integration"),(0,s.kt)("p",null,"Continuous integration is a process for developing software where all the software is stored in a central repository. A repository is usually a network-based storage area that not only stores the software as it is checked in, but versions software by storing all the previous versions. This makes it easy to back out a change in case a mistake is made by simply going back to a previous version of a software."),(0,s.kt)("p",null,"Since software is developed by a large team, it is important to ensure that the software in the repository that everyone checks out to add their own modifications to should be as clean as possible. If bugs get into the code in the repository, than other developers will build upon these bugs. This can cause days or even weeks of work to have to be discarded. To prevent the introduction of bugs into the repository, a rigorous test suite is run on modifications done by every developer before it is checked into the repository. Software can be checked into the repository only after it has passed all of the tests."),(0,s.kt)("p",null,"This testing process can take a considerable amount of time and developers often finish a new feature at the end of the day and then run the test suite as they leave work for the day and let it run during the evening. This allows the developer to not waste time waiting for the test suite to finish running. In large software projects, it is not unusual for the test suite to take two to three hours to run."),(0,s.kt)("p",null,"Continuous integration works best if the software that is checked in is relatively small. This means that you might want to do a check in after implementing a relatively small new feature that might involve just a few new classes or a few new functions. If there is no test already in the system for the software you are adding then you will typically add new tests for it. If you are changing the software to fix a bug, that it is common to include a test the checks to make sure that the old bug never occurs again. A test like this would check specifically for the old bug because it could always come back and you want to make sure that you can detect it in case that ever happens."),(0,s.kt)("p",null,"A typical scenario using continuous integration would look like this:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"you get a request to fix a bug,"),(0,s.kt)("li",{parentName:"ul"},"you check out a copy of the software from the repository to your local computer,"),(0,s.kt)("li",{parentName:"ul"},"you implement the bug fix,"),(0,s.kt)("li",{parentName:"ul"},"optionally, you add a test case to check that the bug you fixed is really fixed,"),(0,s.kt)("li",{parentName:"ul"},"you build the software locally and run the test suite,"),(0,s.kt)("li",{parentName:"ul"},"if the software passes all the tests, you check the modified code into the code repository.")),(0,s.kt)("p",null,"Adding new code features would follow a similar series of steps but might involve the addition of new tests to the test suite to test the new features added. These tests might be added by the developer or by working with a member of the quality assurance team."),(0,s.kt)("p",null,"Continuous integration can be done either manually or automated. When automated, the developer checks in the software and the software is built and the tests are run automatically. Reports are then sent to the interested parties to tell them of the success or failure of the tests. Many systems will not integrate the software into the main code base unless it has built correctly and passed all tests. One possible way of automating continuous integration is shown below."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"&quot;Automated Continuous Integration&quot; ",src:n(3509).Z})),(0,s.kt)("h3",{id:"test-driven-development"},"Test Driven Development"),(0,s.kt)("p",null,"Test driven development writes the tests first and then the code to be tested after the tests are written. The test team usually gets together with the developers and agrees on functions or classes and what they should do. The test team then crafts the tests to ensure the software performs correctly. Once the tests are complete, the developers write the software, ensuring that it does exactly what is required to pass the tests."),(0,s.kt)("p",null,"The advantage of test driven development is that there are no surprises for the developers. They are not faced with writing code and then finding it fails a test they did not expect and need to rewrite the code to pass the test. Now, all tests are known in advance and the code can be crafted to do exacltly what is required."),(0,s.kt)("p",null,"Test driven development can be used as part of continuous integration. The quality assurance team just needs to collaborate closely with the developers and get the tests in place before the coding is done. Once the coding is done, it is tested immediately and, if the tests are passed, it can be checked in. This has the advantage that the tests for all new code are produced automatically as part of the development process."))}d.isMDXComponent=!0},3509:function(e,t,n){t.Z=n.p+"assets/images/continuous-integration-1-11dcdb2daaf0b3b702bd28c737bf143b.png"}}]);